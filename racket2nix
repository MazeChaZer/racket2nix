#! /usr/bin/env racket
#lang racket
(require pkg/lib)

(define header-template #<<EOM
{ pkgs ? import <nixpkgs> {}
, stdenv ? pkgs.stdenv
, fetchurl ? pkgs.fetchurl
, racket ? pkgs.racket
, racket-lib ? racket
, unzip ? pkgs.unzip
}:


EOM
)

(define install-dep-template #<<EOM
    raco pkg install --skip-installed --deps fail --scope-dir $out/share/racket/pkgs ${~a.out}/share/racket/pkgs/~a
EOM
)

(define (install-dep dep-name)
  (format install-dep-template dep-name dep-name))

(define derivation-template #<<EOM
stdenv.mkDerivation rec {
  name = "~a";
  src = fetchurl {
    url = "~a";
    sha1 = "~a";
  };

  buildInputs = [ unzip ~a ];

  unpackPhase = "unzip $src -d $name";

  dontBuild = true;

  inherit racket;

  installPhase = ''
    # TODO: Tell racket not to keep a collection path in \$HOME/.racket
    export PLTUSERHOME=\$PWD

    # Install deps
~a
    raco pkg install --copy --deps fail --scope-dir $out/share/racket/pkgs ./$name
  '';
}
EOM
)

(define (header) header-template)

(define (memo-lookup-package package-dictionary package-name)
  (hash-ref! package-dictionary package-name
             (lambda () (hash-copy (get-pkg-details-from-catalogs package-name)))))

(define (dependency-name pair-or-string)
  (if (pair? pair-or-string)
      (car pair-or-string)
      pair-or-string))

(define (names->let-deps ns package-dictionary)
  (let [(names (remove* '("racket-lib")  ; This is bootstrapped in racket itself
                        ns))]
    (cond
      [(null? names) ""]
      [#t (format "let~n~a~nin~n"
                  (string-join
                   (map (lambda (name)
                          (format "  ~a = ~a;" name
                                  (name->derivation name package-dictionary)))
                        names)
                   (format "~n")))])))

(define (name->transitive-dependency-names package-name package-dictionary (breadcrumbs '("racket-lib")))
  (cond [(member package-name breadcrumbs) (list package-name)]
        [#t (let [(package (memo-lookup-package package-dictionary package-name))]
              (hash-ref! package 'transitive-dependency-names
                         (lambda ()
                           (display (format "evaluating deps of ~a~n" package-name) (current-error-port))
                           (let [(dependency-names (package->transitive-dependency-names package package-dictionary
                                                                                         (cons package-name breadcrumbs)))]
                             (display (format "deps of ~a: ~a~n" package-name dependency-names) (current-error-port))
                             dependency-names))))]))

(define (lists->unique-elements ls)
  (reverse (lists->reverse-unique-elements ls)))

(define (lists->reverse-unique-elements ls)
  (let loop [(lists ls)
             (reverse-unique-elements '())]
    (cond [(null? lists) reverse-unique-elements]
          [(null? (car lists)) (loop (cdr lists) reverse-unique-elements)]
          [#t
           (let [(element (caar lists))
                 (rest-first (cdar lists))]
             (cond [(member element reverse-unique-elements)
                    (loop (cons rest-first (cdr lists)) reverse-unique-elements)]
                   [#t
                    (loop (cons rest-first (cdr lists)) (cons element reverse-unique-elements))]))])))

(define (package->transitive-dependency-names package package-dictionary breadcrumbs)
  (let [(name (hash-ref package 'name))]
    (let [(dependency-names (remove* '("racket") (map dependency-name (hash-ref package 'dependencies))))]
      (reverse (cons name (lists->reverse-unique-elements
                           (map (lambda (name) (name->transitive-dependency-names name package-dictionary breadcrumbs))
                                dependency-names)))))))

(define (name->derivation package-name package-dictionary)
  (let [(package (memo-lookup-package package-dictionary package-name))]
    (display (format "Create derivation for ~a~n" package-name) (current-error-port))
    (package->derivation package package-dictionary)))

(define (package->derivation package package-dictionary)
  (letrec [(name (hash-ref package 'name))
	   (url (hash-ref package 'source))
	   (sha1 (hash-ref package 'checksum))
           (dependency-names (remove* '("racket")  ; racket may or may not be in here
                                      (map dependency-name
                                           (hash-ref package 'dependencies))))]
    (format derivation-template name url sha1
            (string-join (cons "racket" dependency-names))  ; racket needs to be in here
            (string-join   ; no racket here
             (map install-dep (lists->unique-elements (map (lambda (name) (name->transitive-dependency-names name package-dictionary))
                                                           dependency-names)))
             (format "~n")))))

(define (name->let-deps-and-reference package-name (package-dictionary (make-hash)))
  (letrec [(package-names (name->transitive-dependency-names package-name package-dictionary))
           (package-definitions (names->let-deps package-names package-dictionary))]
    (string-append package-definitions package-name (format "~n"))))

(let [(package-name (read-line (current-input-port) 'any))]
  (display (string-append (header) (name->let-deps-and-reference package-name))))
